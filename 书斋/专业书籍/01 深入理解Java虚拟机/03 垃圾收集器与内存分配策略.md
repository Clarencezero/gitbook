# 垃圾收集器与内存分配策略

## 3.1 概述

GC 需要完成三件事：

1. 哪些内存需要回收?
2. 什么时候回收?
3. 如何回收?

> 第二章介绍了 Java 内存运行时区域的各个部分。
>
> **程序计数器、虚拟机栈、本地方法栈**三个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧需要分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化，但是大体上可以认为是编译器可知的），因此在这几个区域的内存分配和回收都具有确定性，这几个区域不太需要过多地考虑回收的问题。
>
> 而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分的内存分配和回收都是动态的，垃圾收集器需要关注的是这部分内存，我们所讨论的“内存”分配与回收也仅仅指着一部分。

## 3.2 对象已死?

### 3.2.1 引用计数法

很难解决对象之间的相互循环引用的问题。

### 3.2.2 可达性分析算法*Reachability Analysis*

基本思路是：通过一系列的名字为**GC Roots**的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（*Reference Chain*），当一个对象到 GC Roots 没有任何引用链对象相连（用图论的话说，就是从 GC Roots 到这个对象不可到达）时，则证明此对象不可用。

![Reachability Analysis](https://cdn.jsdelivr.net/gh/Clarencezero/poi/gc root.png)

在 Java 语言中，可作为 GC Roots 的对象包括下面几种:

- 虚拟机**栈**（栈中的本地变量表）中的引用的对象
- **方法区**中的类静态属性引用的对象
- **方法区**中的常量引用的对象
- 本地方法栈中 JNI（即一般说的 Native 方法）的引用的对象

### 3.2.3 再谈引用

JDK1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

1. 强引用

   被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。
   ```java
   Object obj = new Object();
   ```

   这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。 

2. 软引用

   被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。用来描述一些还有用，但是并非必需的对象。

   在系统将要发生内存溢出异常之前，将会把这些对象放进回收范围之中并进行第二次的回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。

   ```java
   Object obj = new Object();
   SoftReference<Object> sf = new SoftReference<Object>(obj);
   obj = null;  // 使对象只被软引用关联
   ```

3. 弱引用

   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 
   
   当垃圾回收器工作时，不论当前内存是否足够，都会回收掉只被弱引用关联的对象。
   
   使用 WeakReference 类来创建弱引用。
   
   ```java
   Object obj = new Object();
   WeakReference<Object> wf = new WeakReference<Object>(obj);
   obj = null;
   ```

4. 虚引用

   也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不影响其生存时间，也无法通过虚引用来获取一个对象的实例。

   为一个对象设置虚引用的唯一目的就是希望这个对象被收集器回收时收到一个系统通知。

   在 JDK1.2 之后，提供了 PhantomReference 类来实现虚引用。

   ```java
   Object obj = new Object();
   PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
   obj = null;
   ```

### 3.2.4 生存还是死亡?

要真正宣告对象的死亡，至少要经历两次标记：

如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它就会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象就会被放在名为 F-Queue 的队列中，并在稍后有一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所说的“执行”是指虚拟机会触发这个方法，但是并不承诺会保证等待它运行结束。（这样做的目的是，如果一个对象在 finalize() 方法中执行缓慢或者是发生了死循环，将可能会导致 F-Queue 里的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃）。 finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize() 方法中成功拯救自己，只要重新与引用链上的任何对象建立关联即可，譬如把自己（this 关键字）复制给某个类变量或者对象的成员变量。

它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。

### 3.2.5 回收方法区

**Q:**方法区与永久代的关系?

很多文章里喜欢把方法区等同与永久代，永久代既然没了，方法区也就没了。但我认为方法区只是一种逻辑上的概念，永久代指物理上的堆内存的一块空间，这块实际的空间完成了方法区存储字节码、静态变量、常量的功能等等。既然如此，现在元空间也可以认为是新的方法区的实现了。

**Q:**常量池随永久代的变化

常量池分以下几种:
1. 静态常量池。
   即*.class 文件中的常量池，class 文件中的常量池不仅仅包含字符串/数字这些字面量，还包含类、方法的信息，占用 class 文件绝大部分空间。这种常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于 Java 语言层面常量的概念，如文本字符串，声明为 final 的常量值等；符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名、字段名称描述符、方法名称描述符。 

   类的加载过程中的链接部分的解析步骤就是把符号引用替换为直接引用，即把那些描述符（名字）替换为能直接定位到字段、方法的引用或句柄（地址）。

2. 运行时常量池。
   而运行时常量池，则是 jvm 虚拟机在完成类装载操作后，将 class 文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池相对于 CLass 文件常量池的另外一个重要特征是**具备动态性**，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 CLass 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String 类的 intern()**方法。 

常量池的好处
1. 节省内存空间: 常量池中所有相同的字符串常量被合并，只占用一个空间
2. 节省运行时间: 比较字符串时，`==` 比`equals()`快。只用`==`判断引用是否相等，也就可以判断实际值是否相等。

```java
String s1 = "hello";
String s2 = "hello";
System.out.println(s1 == s2); // true
```

编译期间，字面量会直接放入`class`文件的常量池中，从而实现 Class 领域内的复用。载入运行时常量池后，s1、s2 指向的是同一个内存地址。

```java
String s3 = "hel" + "lo";
String s4 = "hel" + new String("lo");
System.out.println(s1 == s3);  // true
System.out.println(s1 == s4);  // false
```

s3 虽然是拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化。因此，在 class 文件中 s3 存储为`hello`。所以`s1==s3`为 true。
**只有使用引号包含文本的方式创建的 String 对象之间使用`+`连接产生的新对象才会被加入字符串池中。**

s1 和 s4 当然不对等。s4 虽然也是拼接出来，但是对于`new String("lo");`这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果。所以不清楚 s4 分配的地址是在哪里，所以地址肯定不同。

```java
String s5 = new String("hello");
String s6 = s5.intern();
System.out.println(s1 == s6);  // true
```

intern 方法会尝试将`hello`字符串添加到常量池中，并返回其在常量池中的地址。因为常量池中已经存在了 hello 字符串，所以 intern 方法直接返回地址。

结论: 

1. 必须关注编译期的行为，才能更好的理解常量池。
2. 运行时常量池中的常量，基本来源于各个 class 文件中的常量池。
3. 程序运行时，除非手动向常量池中添加常量 (比如`intern`方法)，否则 JVM 不会自动添加常量到常量池。

Byte,Short,Integer,Long,Character,Boolean 这 5 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 

## 3.3 垃圾收集算法

### 3.3.1 标记-清除算法

![标记-清除 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/标记-清除.png)

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 3.3.2 复制算法

![复制 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/复制.png)

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

### 3.3.3 标记-整理算法

![标记-整理 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/标记-整理.png)

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

### 3.3.4 分代收集算法

当前商业虚拟机的垃圾收集都是采用“分代收集（Generational Collection）算法”，根据对象的存活周期的不同将内存划分为几块。 一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特定采用最适当的收集算法。在新生代，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成省收集。而老年代中因为对象存活率高，没有额外的空间进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。



## 3.4 HotSpot 的算法实现

### 3.4.1 枚举根节点

虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中,是使用一组称为 OopMap 的数据结构来达到这个目的。

在类加载完成的时候,HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来,在 JIT 编译过程中,也会在特定的位置记录下栈和寄存器中哪些位置是引用。

### 3.4.2 安全点

**Q:**OopMap 内容变化指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的空间，这样 GC 的空间成本将会变得更高。

实际上，HotSpot 也的确没有为每条指令都生成 OopMap，只在特定的位置记录了这些信息，这些位置称为安全点`Saftpoint`，即程序执行时并非在所有地方都能停顿下来开始 GC，只有到达安全点时才能暂停。

安全点的选择基本是以程序是否具有让程序长时间执行的特征"为标准进行选定。长时间执行的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等。所以具有这些这些功能的指令都会产生 safepoint。

**主动式中断**: 当 GC 需要中断线程的时候,不直接对线程操作,仅仅简单地设置一个标志,各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的,另外再加上创建对象需要分配内存的专访。

## 3.5 垃圾收集器

![HotSpot 7 个垃圾收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/垃圾收集器.jpg)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

### 3.5.1. Serial 收集器

![Serial 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/Serial-收集器.jpg)

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

### 3.5.2. ParNew 收集器

![ParNew 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/ParNew-收集器.jpg)

它是 Serial 收集器的多线程版本。

它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

### 3.5.3. Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### 3.5.4. Serial Old 收集器

![Serial Old 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/Serial-old.jpg)

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### 3.5.5. Parallel Old 收集器

![Parallel Old](https://cdn.jsdelivr.net/gh/Clarencezero/poi/Parallel-Old-收集器.jpg)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### 3.5.6. CMS 收集器

![CMS 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/CMS-收集器.jpg)

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中**耗时最长**，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

### 3.5.7. G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 

![G1 Heap Allocation](https://cdn.jsdelivr.net/gh/Clarencezero/poi/G1-2.png) 

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![G1 垃圾回收](https://cdn.jsdelivr.net/gh/Clarencezero/poi/G1-3.jpg)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记

- 并发标记

- 最终标记

  为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。

- 筛选回收

  首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

### 3.5.8 ZGC

 ZGC所采用的算法就是Azul Systems很多年前提出的Pauseless GC。[论文](https://www.usenix.org/legacy/events/vee05/full_papers/p46-click.pdf)

### 3.5.8 理解 GC 日志

#### 1. CMS GC日志

```shell
// 阶段1：Initial Mark
[GC (CMS Initial Mark) [1 CMS-initial-mark: 0K(2097152K)] 620856K(3040896K), 0.1337462 secs] [Times: user=0.36 sys=0.00, real=0.13 secs] 

// 阶段2：并发标记
2019-06-24T14:26:28.421+0800: 4.344: [CMS-concurrent-mark-start]
2019-06-24T14:26:28.448+0800: 4.370: [CMS-concurrent-mark: 0.026/0.026 secs] [Times: user=0.08 sys=0.01, real=0.03 secs] 

// 阶段3：Concurrent Preclean
2019-06-24T14:26:28.448+0800: 4.370: [CMS-concurrent-preclean-start]
2019-06-24T14:26:28.452+0800: 4.375: [CMS-concurrent-preclean: 0.004/0.004 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 

// 阶段4：Concurrent Abortable Preclean
2019-06-24T14:26:28.452+0800: 4.375: [CMS-concurrent-abortable-preclean-start]
2019-06-24T14:26:28.892+0800: 4.815: [GC (Allocation Failure) 2019-06-24T14:26:28.892+0800: 4.815: [ParNew2019-06-24T14:26:28.946+0800: 4.868: [CMS-concurrent-abortable-preclean: 0.066/0.493 secs] [Times: user=1.79 sys=0.09, real=0.49 secs] 
: 838912K->92239K(943744K), 0.1086553 secs] 838912K->92239K(3040896K), 0.1088052 secs] [Times: user=0.31 sys=0.05, real=0.11 secs] 

// 阶段5：Final Remark
2019-06-24T14:26:29.001+0800: 4.924: [GC (CMS Final Remark) [YG occupancy: 113547 K (943744 K)]2019-06-24T14:26:29.001+0800: 4.924: [Rescan (parallel) , 0.0273029 secs]2019-06-24T14:26:29.029+0800: 4.951: [weak refs processing, 0.0000370 secs]2019-06-24T14:26:29.029+0800: 4.951: [class unloading, 0.0057905 secs]2019-06-24T14:26:29.035+0800: 4.957: [scrub symbol table, 0.0038963 secs]2019-06-24T14:26:29.038+0800: 4.961: [scrub string table, 0.0006268 secs][1 CMS-remark: 0K(2097152K)] 113547K(3040896K), 0.0391238 secs] [Times: user=0.13 sys=0.00, real=0.04 secs] 

// 阶段6：Concurrent Sweep
2019-06-24T14:26:29.041+0800: 4.963: [CMS-concurrent-sweep-start]
2019-06-24T14:26:29.041+0800: 4.963: [CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

// 阶段7：Concurrent Reset.
2019-06-24T14:26:29.041+0800: 4.963: [CMS-concurrent-reset-start]
2019-06-24T14:26:29.049+0800: 4.971: [CMS-concurrent-reset: 0.008/0.008 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
```

[博客](https://www.jianshu.com/p/cd591e2f7946)

#### 2. G1 GC 日志

和其他垃圾收集器一样，G1也使用

```shell
-XX:PrintGCDetails
```

打印出详细的垃圾收集日志，下面这张图是新生代收集的标准流程，我在这里将它分成了6个步骤：

##### 2.1 新生代收集

![新生代收集](https://cdn.jsdelivr.net/gh/Clarencezero/poi/g1 gc new.png)

1. 四个关键信息

   - 新生代垃圾收集发生的时间——**2016-12-12T10:40:18.811-0500**，通过设置`-XX:+PrintGCDateStamps`参数可以打印出这个时间；
   - JVM启动后的相对时间——**25.959**
   - 这次收集的类型——新生代收集，只回收Eden分区
   - 这次收集花费的时间——**0.0305171s，即30ms**

2. 列出了新生代收集中并行收集的详细过程

   - **Parallel Time**：并行收集任务在运行过程中引发的STW（Stop The World）时间，从新生代垃圾收集开始到最后一个任务结束，共花费26.6ms

   - **GC Workers**：有4个线程负责垃圾收集，通过参数`-XX:ParallelGCThreads`设置，这个参数的值的设置，跟CPU有关，如果物理CPU支持的线程个数小于8，则最多设置为8；如果物理CPU支持的线程个数大于8，则默认值为number * 5/8

   - **GC Worker Start**：第一个垃圾收集线程开始工作时JVM启动后经过的时间（min）；最后一个垃圾收集线程开始工作时JVM启动后经过的时间（max）；diff表示min和max之间的差值。理想情况下，你希望他们几乎是同时开始，即diff趋近于0。

   - **Ext Root Scanning**：扫描root集合（线程栈、JNI、全局变量、系统表等等）花费的时间，扫描root集合是垃圾收集的起点，尝试找到是否有root集合中的节点指向当前的收集集合（CSet）

   - Update RS(Remembered Set or RSet)

     ：每个分区都有自己的RSet，用来记录其他分区指向当前分区的指针，如果RSet有更新，G1中会有一个post-write barrier管理跨分区的引用——新的被引用的card会被标记为dirty，并放入一个日志缓冲区，如果这个日志缓冲区满了会被加入到一个全局的缓冲区，在JVM运行的过程中还有线程在并发处理这个全局日志缓冲区的dirty card。

     Update RS

     表示允许垃圾收集线程处理本次垃圾收集开始前没有处理好的日志缓冲区，这可以确保当前分区的RSet是最新的。

     - **Processed Buffers**，这表示在Update RS这个过程中处理多少个日志缓冲区。

   - **Scan RS**：扫描每个新生代分区的RSet，找出有多少指向当前分区的引用来自CSet。

   - **Code Root Scanning**：扫描代码中的root节点（局部变量）花费的时间

   - **Object Copy**：在疏散暂停期间，所有在CSet中的分区必须被转移疏散，Object Copy就负责将当前分区中存活的对象拷贝到新的分区。

   - Termination

     ：当一个垃圾收集线程完成任务时，它就会进入一个临界区，并尝试帮助其他垃圾线程完成任务（steal outstanding tasks），min表示该垃圾收集线程什么时候尝试terminatie，max表示该垃圾收集回收线程什么时候真正terminated。

     - **Termination Attempts**：如果一个垃圾收集线程成功盗取了其他线程的任务，那么它会再次盗取更多的任务或再次尝试terminate，每次重新terminate的时候，这个数值就会增加。

   - **GC Worker Other**：垃圾收集线程在完成其他任务的时间

   - **GC Worker Total**：展示每个垃圾收集线程的最小、最大、平均、差值和总共时间。

   - **GC Worker End**：min表示最早结束的垃圾收集线程结束时该JVM启动后的时间；max表示最晚结束的垃圾收集线程结束时该JVM启动后的时间。理想情况下，你希望它们快速结束，并且最好是同一时间结束。

3. 列出了新生代GC中的一些任务：

   - **Code Root Fixup** ：释放用于管理并行垃圾收集活动的数据结构，应该接近于0，该步骤是线性执行的；
   - **Code Root Purge**：清理更多的数据结构，应该很快，耗时接近于0，也是线性执行。
   - **Clear CT**：清理card table

4. 包含一些扩展功能

   - **Choose CSet**：选择要进行回收的分区放入CSet（G1选择的标准是垃圾最多的分区优先，也就是存活对象率最低的分区优先）
   - **Ref Proc**：处理Java中的各种引用——soft、weak、final、phantom、JNI等等。
   - **Ref Enq**：遍历所有的引用，将不能回收的放入pending列表
   - **Redirty Card**：在回收过程中被修改的card将会被重置为dirty
   - **Humongous Register**：JDK8u60提供了一个特性，巨型对象可以在新生代收集的时候被回收——通过`G1ReclaimDeadHumongousObjectsAtYoungGC`设置，默认为true。
   - **Humongous Reclaim**：做下列任务的时间：确保巨型对象可以被回收、释放该巨型对象所占的分区，重置分区类型，并将分区还到free列表，并且更新空闲空间大小。
   - **Free CSet**：将要释放的分区还回到free列表。

5. 展示了不同代的大小变化，以及堆大小的自适应调整。

   - **Eden:1097.0M(1097.0M)->0.0B(967.0M)**：（1）当前新生代收集触发的原因是Eden空间满了，分配了1097M，使用了1097M；（2）所有的Eden分区都被疏散处理了，在新生代结束后Eden分区的使用大小成为了0.0B；（3）Eden分区的大小缩小为967.0M
   - **Survivors:13.0M->139.0M**：由于年轻代分区的回收处理，survivor的空间从13.0M涨到139.0M；
   - **Heap:1694.4M(2048.0M)->736.3M(2048.0M)**：（1）在本次垃圾收集活动开始的时候，堆空间整体使用量是1694.4M，堆空间的最大值是2048M；（2）在本次垃圾收集结束后，堆空间的使用量是763.4M，最大值保持不变。

6. 第6点展示了本次新生代垃圾收集的时间

   - **user=0.8**：垃圾收集线程在新生代垃圾收集过程中消耗的CPU时间，这个时间跟垃圾收集线程的个数有关，可能会比real time大很多；
   - **sys=0.0**：内核态线程消耗的CPU时间
     -**real=0.03**：本次垃圾收集真正消耗的时间；

##### 2.2 并发垃圾收集

G1的第二种收集活动是并发垃圾收集，并发垃圾收集的触发条件有很多，但是做的工作都相同，它的日志如下图所示：

![并发垃圾收集](https://cdn.jsdelivr.net/gh/Clarencezero/poi/g1 gc concurrent.png)

1. 标志着并发垃圾收集阶段的开始：
   - **GC pause(G1 Evacuation Pause)(young)(initial-mark)**：为了充分利用STW的机会来trace所有可达（存活）的对象，initial-mark阶段是作为新生代垃圾收集中的一部分存在的（搭便车）。initial-mark设置了两个TAMS（top-at-mark-start）变量，用来区分存活的对象和在并发标记阶段新分配的对象。在TAMS之前的所有对象，在当前周期内都会被视作存活的。
2. 表示第并发标记阶段做的第一个事情：根分区扫描
   - **GC concurrent-root-region-scan-start**：根分区扫描开始，根分区扫描主要扫描的是新的survivor分区，找到这些分区内的对象指向当前分区的引用，如果发现有引用，则做个记录；
   - **GC concurrent-root-region-scan-end**：根分区扫描结束，耗时0.0030613s
3. 表示并发标记阶段
   - **GC Concurrent-mark-start**：并发标记阶段开始。（1）并发标记阶段的线程是跟应用线程一起运行的，不会STW，所以称为并发；并发标记阶段的垃圾收集线程，默认值是Parallel Thread个数的25%，这个值也可以用参数`-XX:ConcGCThreads`设置；（2）trace整个堆，并使用位图标记所有存活的对象，因为在top TAMS之前的对象是隐式存活的，所以这里只需要标记出那些在top TAMS之后、阈值之前的；（3）记录在并发标记阶段的变更，G1这里使用了SATB算法，该算法要求在垃圾收集开始的时候给堆做一个快照，在垃圾收集过程中这个快照是不变的，但实际上肯定有些对象的引用会发生变化，这时候G1使用了pre-write barrier记录这种变更，并将这个记录存放在一个SATB缓冲区中，如果该缓冲区满了就会将它加入到一个全局的缓冲区，同时G1有一个线程在并行得处理这个全局缓冲区；（4）在并发标记过程中，会记录每个分区的存活对象占整个分区的大小的比率；
   - **GC Concurrent-mark-end**：并发标记阶段结束，耗时0.3055438s
4. 重新标记阶段，会Stop the World
   - **Finalize Marking**：Finalizer列表里的Finalizer对象处理，耗时0.0014099s；
   - **GC ref-proc**：引用（soft、weak、final、phantom、JNI等等）处理，耗时0.0000480s；
   - **Unloading**：类卸载，耗时0.0025840s；
   - 除了前面这几个事情，这个阶段最关键的结果是：绘制出当前并发周期中整个堆的最后面貌，剩余的SATB缓冲区会在这里被处理，所有存活的对象都会被标记；
5. 清理阶段，也会Stop the World
   - 计算出最后存活的对象：标记出initial-mark阶段后分配的对象；标记出至少有一个存活对象的分区；
   - 为下一个并发标记阶段做准备，previous和next位图会被清理；
   - 没有存活对象的老年代分区和巨型对象分区会被释放和清理；
   - 处理没有任何存活对象的分区的RSet；
   - 所有的老年代分区会按照自己的存活率（存活对象占整个分区大小的比例）进行排序，为后面的CSet选择过程做准备；
6. 并发清理阶段
   - **GC concurrent-cleanup-start**：并发清理阶段启动。完成第5步剩余的清理工作；将完全清理好的分区加入到二级free列表，等待最终还会到总体的free列表；
   - **GC concurrent-cleanup-end**：并发清理阶段结束，耗时0.0012954s

##### 2.3 混合收集

在并发收集阶段结束后，你会看到混合收集阶段的日志，如下图所示，该日志的大部分跟之前讨论的新生代收集相同，只有第1部分不一样：**GC pause(G1 Evacuation Pause)(mixed),0.0129474s**，这一行表示这是一个混合垃圾收集周期；在混合垃圾收集处理的CSet不仅包括新生代的分区，还包括老年代分区——也就是并发标记阶段标记出来的那些老年代分区。 

![混合收集](https://cdn.jsdelivr.net/gh/Clarencezero/poi/g1 gc mix collect.png)



##### 2.5 Full GC

如果堆内存空间不足以分配新的对象，或者是Metasapce空间使用率达到了设定的阈值，那么就会触发Full GC——你在使用G1的时候应该尽量避免这种情况发生，因为G1的Full Gc是单线程、会Stop The World，代价非常高。Full GC的日志如下图所示，从中你可以看出三类信息

1. Full GC的原因，这个图里是Allocation Failure，还有一个常见的原因是Metadata GC Threshold；
2. Full GC发生的频率，每隔几天发生一次Full GC还可以接受，但是每隔1小时发生一次Full GC则不可接受；
3. Full GC的耗时，这张图里的Full GC耗时150ms（PS：按照我的经验，实际运行中如果发生Full GC，耗时会比这个多很多）

![Full GC](https://cdn.jsdelivr.net/gh/Clarencezero/poi/g1 gc full gc.png)

在配置参数里面，以下两个参数能提供有用信息:

```shell
-XX:+PrintGCApplicationStoppedTime
-XX:+PrintGCApplicationConcurrentTime
```

![Full GC](https://cdn.jsdelivr.net/gh/Clarencezero/poi/jvm two params.png)

1. 记录了应用线程在安全点被暂停的总时间（也就是STW的总时间）
2. 记录了让所有应用线程进入安全点所花费的总时间
3. 记录了在两个安全点之间应用线程运行的时间

### 3.5.10 垃圾收集器参数总结

[你假笨官网](https://opts.console.perfma.com/)

[你假笨论坛](https://club.perfma.com/)

[Java的GC为什么要分代](https://www.zhihu.com/question/53613423/answer/135743258)

> 对于这些GC来说，解决stop-the-world时间太长的问题并不是选择分代的主要原因。
> 就Azul的Pauless到C4的发展历程来看，选择实现分代的最大好处是，GC能够应付的应用内存分配速率（allocation rate）可以得到巨大的提升。
> 并发GC根本上要跟应用玩追赶游戏：应用一边在分配，GC一边在收集，如果GC收集的速度能跟得上应用分配的速度，那就一切都很完美；一旦GC开始跟不上了，垃圾就会渐渐堆积起来，最终到可用空间彻底耗尽的时候，应用的分配请求就只能暂时等一等了，等GC追赶上来。
> 所以，对于一个并发GC来说，能够尽快回收出越多空间，就能够应付越高的应用内存分配速率，从而更好地保持GC以完美的并发模式工作。
> 虽然并不是所有应用中的对象生命周期都完美吻合weak generational hypothesis的假设，但这个假设在很大范围内还是适用的，因而也可以帮助并发GC改善性能。

[Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/question/53613423/answer/135743258)



## 3.6 内存分配与回收策略

### 3.6.1 对象优先在 Eden 分配

 大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 **Minor GC**。 

### 3.6.2 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

```shell
-XX:PretenureSizeThreshold
```

大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

### 3.6.3 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

```shell
-XX:MaxTenuringThreshold
```

 用来定义年龄的阈值。

### 3.6.4 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

### 3.7.3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。

### 3.7.4. JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

### 3.7.5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。










